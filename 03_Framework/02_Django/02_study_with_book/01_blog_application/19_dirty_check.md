# Dirty Check

## 1. ORM 과 Dirty Check

Dirty Check 는 ORM 에서 객체의 속성이 변경되었는지 추적하는 과정이다. 객체의 속성이 초기 상태와 비교하여 변경되었을 때, 이를 "더럽혀졌다(dirty)"고 표현한다.

Dirty Check 를 통해 실제로 변경된 값을 가진 객체만 데이터베이스에 업데이트할 수 있어 성능을 최적화하고 불필요한 쿼리를 줄일 수 있다.

예를 들어, 서버의 RAM 에 존재하는 Entity 가 더럽혀지지 않았다고 판단되면(DB 에 있는 값과 일치하다는 것이 보장되었다면) 굳이 DB 서버에 Connection 을 하여 리소스를 낭비하지 않고 서버의 RAM 에 존재하는 Entity 의 값을 바로 이용할 수 있다.

위와 같이 서버의 RAM 에 존재하는 Entity 의 정보를 사용하면, 빠르게 응답할 수 있고 리소스 또한 절약할 수 있다.

## 2. Dirty Check 와 Caching
캐시는 자주 조회되는 데이터를 메몸리 등에 저장하여, 이후의 요청에서 빠르게 접근할 수 있도록 하는 기법이다. 캐시를 사용하면 데이터베이스 쿼리의 수를 줄이고 성능을 향상시킬 수 있다.

캐시된 데이터가 업데이트될 때 Dirty Check 를 통해 변경된 내용을 확인하고, 캐시를 최신 상태로 유지하는 것이 중요하다.

예를 들어, 데이터베이스에서 객체를 수정한 후, 변경된 내용을 캐시에 반영해야 하며, 이때 Dirty Check 를 사용하여 어떤 데이터가 변경되었는지 확인할 수 있다.

## 3. Django 가 Dirty Check 를 하는 방법
Django 에서는 모델 인스턴스의 필드가 변경되었는지를 감지하기 위해 내부적으로 dirty 상태를 관리한다. 이는 다음과 같은 방식으로 이루어진다.

### 3-1. 모델 인스턴스 생성
모델 인스턴스가 생성될 때, Django 는 각 필드의 초기 값을 저장한다.

### 3-2. 필드 변경 감지
필드 값이 변경될 때, Django 는 이전 값과 현재 값을 비교하여 변경 사항을 감지한다.

### 3-3. 저장 시점
save() 메서드가 호출될 때, Django 는 Dirty Check 를 통해 변경된 필드만 데이터베이스에 업데이트한다.

### 3-4. Dirty 상태 확인
사용자가 직접 is_Dirty() 같은 메서드를 호출하여 객체의 변경 여부를 확인할 수 있다. (기본적으로 제공 되는 메서드는 아니지만, 사용자 정의 메서드로 구현할 수 있으며, django-model-utils 와 같은 패키지를 사용하면 비슷한 기능을 제공할 수 있다.)

## 4. Dirty Check 와 관련해서 알아야 할 점

### 4-1. 성능 최적화
Dirty Check 를 통해 불필요한 데이터베이스 호출을 줄여 성능을 최적화할 수 있다. 이는 특히 대규모 애플리케이션에서 중요하다.

### 4-2. 일관성 유지
Dirty Check 는 데이터의 일관성을 유지하는 데 도움을 준다. 변경된 데이터만 업데이트되므로, 데이터베이스의 상태와 애플리케이션의 상태를 일치시킬 수 있다.

### 4-3. 복잡한 객체 상태 관리
복잡한 객체 구조를 가진 경우, Dirty Check 를 통해 각 객체의 상태를 개별적으로 관리할 수 있다.

### 4-4. 추가적인 관리 필요
Dirty Check 를 사용할 때는 신뢰성을 유지하기 위해 명확한 기준을 설정하고, 필요한 경우 수동으로 상태를 초기화하는 방법을 고려해야 한다.

JPA 는 Optimistic Locking 과 Pessimistic Locking 을 통해 동시성 문제를 처리할 수 있는 기능을 제공한다. 사용자가 이러한 기능을 적절히 활용하면, 여러 사용자가 동일한 객체를 수정할 때 발생할 수 있는 데이터 충돌이나 불일치를 효과적으로 관리할 수 있다.

그러나 Django 는 기본적으로 자동 지원하지 않는다. 그에 따라 수동으로 구현하거나 외부 라이브러리를 사용해야 함을 염두해 두자.

#### Optimistic Locking
Optimistic Locking 은 데이터베이스의 동시성 제어 방식 중 하나로, 데이터 충돌이 발생하지 않을 것이라는 가정 하에 작동하는 방식이다. 데이터베이스에 실제로 업데이트를 시도하기 전에 현재 상태를 확인하여 충돌을 감지한다.

Entity 에 버전 필드를 추가하여 각 데이터 레코드의 버전을 관리한다. 이 필드는 객체가 수정될 때마다 증가한다.

#### Pessimistic Locking
Pessimistic Locking 은 데이터 충돌이 발생할 가능성이 높다고 가정하고, 데이터를 수정하기 전에 해당 데이터를 잠그는 방식이다. 이는 다른 트랜잭션이 동시에 해당 데이터를 수정하지 못하도록 하는 방법이다.

다만, Lock(잠금)으로 인해 성능 저하가 발생할 수 있으며, 데드락 문제가 발생할 수 있다.

#### 정리
Optimistic Locking 과 Pessimistic Locking 은 각각의 상황에 맞게 선택하여 사용할 수 있는 동시성 제어 방식이다. Optimistic Locking 은 충격이 드물게 발생하는 경우, Pessimistic Locking 은 데이터 충돌이 자주 발생할 가능성이 높은 경우에 적합하다.