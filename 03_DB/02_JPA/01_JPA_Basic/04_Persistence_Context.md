# Persistence Context (영속성 컨텍스트)

## 1. 영속성 컨텍스트란?
영속성 컨텍스트는 JPA 에서 엔티티의 상태를 관리하는 환경이다. JPA 는 자바의 객체와 데이터베이스의 한 row 를 매핑하는 것이 주요 역할인데, 이 때 자바의 객체를 엔티티라고 한다.

데이터베이스와 자바의 객체는 안정성 측면에서 큰 차이가 난다. Entity(Java의 객체) 메모리에 저장되고, 데이터베이스는 디스크에 존재한다. 그렇기 때문에, 자바의 객체는 프로그램의 실행 여부에 의존적이다. 다시 말해, 프로그램을 종료하면 Entity 는 사라질 수 있다는 것이다.

JPA 는 영속성이라는 개념을 도입하여 이러한 문제를 해결하고, 이 과정에 영속성 컨텍스트가 관여한다.

---

<영속성의 정의></br>
영속성 컨텍스트는 JPA 에서 엔티티의 상태를 관리하는 환경이다. 메모리 내에서 인스턴스를 유지하고, 데이터베이스와의 상호작용을 위해 데이터의 일관성을 유지한다. 여기에서 영속성 컨텍스트가 관여하는데, 영속성 컨텍스트는 엔티티의 생명 주기를 관리하며, 이를 통해 데이터베이스에 대한 CRUD(Create, Read, Update, Delete) 작업을 효율적으로 수행한다.

## 2. JPA 에서 영속성 컨텍스트가 하는 일들

### 2-1. 엔티티의 상태 관리
영속성 컨텍스트에 저장된 Entity 는 Managed 상태로 관리되며, JPA 영속성 컨텍스트에 의해 관리되는 엔티티의 변경 사항을 자동으로 감지할 수 있게 된다. 이후 트랙잭션이 커밋될 때, JPA 는 자동으로 flush() 메서드를 호출하여 변경된 엔티티의 상태를 데이터베이스에 반영한다. 이 과정에서 변경된 값이 데이터베이스에 저장된다.

### 2-2. 변경 감지 (Dirty Checking)
영속성 컨텍스트 내에서 엔티티의 필드가 변경되면, JPA 는 이를 자동으로 감지하여 트랙잭션이 커밋될 때 데이터베이스에 반영한다. 이를 통해 개발자는 별도로 Update 쿼리를 작성할 필요가 없다.

### 2-3. 플러시 (Flush)
영속성 컨텍스트의 상태를 데이터베이스에 반영하기 위해 flush() 메서드를 호출할 수 있다. 이 과정에서 변경된 엔티티의 상태가 데이터베이스에 업데이트 된다. 자동으로 플러시되는 시점은 트랙잭션 커밋 시점이다.

### 2-4. 엔티티 조회
영속성 컨텍스트는 엔티티를 조회할 때, 먼저 캐시에서 해당 엔티티를 찾고, 존재하지 않는 경우에는 데이터베이스에서 조회한다. 이를 통해 동일한 엔티티에 대한 중복 조회를 줄여 성능을 최적화한다.

### 2-5. 트랜잭션 관리
영속성 컨텍스트는 일반적으로 트랜잭션 범위 내에서 생성되며, 트랜잭션이 시작되면 엔티티를 영속성 컨텍스트에 추가하고, 트랜잭션이 종료되는 상태를 데이터베이스에 반영한다.

### 2-6. 엔티티 생명 주기 관리
영속성 컨텍스트는 엔티티의 생명 주기를 관리하며, 상태 (Transient, Managed, Detached, Removed) 를 변화시킨다. 예를 들어, 영속성 컨텍스트에서 삭제된 엔티티는 Removed 상태로 변경된다.

### 2-7. 쿼리 실행
영속성 컨텍스트는 JPQL(Java Persistence Query Language) 및 Criteria API 를 사용해서 데이터베이스 쿼리를 실행하고, 결과를 엔티티로 매핑한다.

### 2-8. 연관 관계 쿼리
영속성 컨텍스트는 엔티티 간의 연관 관계를 관리하며, 이를 통해 외래 키의 변경 및 연관된 엔티티의 상태를 자동으로 동기화한다.

### 2-9. Cascade Operations
영속성 컨텍스트는 엔티티의 상태가 변경될 때, 연관된 엔티티에 대한 전파 작업을 수행하여 일관성을 유지한다. 예를 들어, 부모 엔티티가 삭제될 때 자식 엔티티도 함께 삭제할 수 있다.